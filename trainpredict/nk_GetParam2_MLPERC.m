% ==========================================================================
% FORMAT [param, model] = nk_GetParam_MLP(Y, label, SlackParam, ~, ...
%                                           ModelOnly)
% ==========================================================================
% Train MLP models in python and evaluate their performance using Y & label, 
% SlackParam,
% if ModelOnly = 1, return only model
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% (c) Sergio Mena Ortega, 2024

function [param, model] = nk_GetParam2_MLPERC(Y, label, ModelOnly, Param)
global EVALFUNC MODEFL GRD

param = [];

%Extracting structure of NN. 
struc = GRD.MLPERC.Params(1).range(Param{1}, :);

%Removing 0's from structure. 
Param{1} = struc(struc ~= 0);

%Formatting for python. 
for i = [12, 14, 15]
    if Param{i} == 1
        Param{i} = true;
    elseif  Param{i} == 0
        Param{i} = false;
    end
end



switch MODEFL
    case 'classification'
        if iscell(Y)  % MCL-based learning not implemented yet
        else % Univariate case
            model = py.sklearn.neural_network.MLPClassifier( ...
                hidden_layer_sizes = int64(Param{1}), ...
                activation = Param{2}, ...
                solver = Param{3}, ...
                alpha = double(Param{4}), ...
                batch_size = Param{5}, ...
                learning_rate = Param{6}, ...
                learning_rate_init = double(Param{7}), ...
                power_t = double(Param{8}), ...
                max_iter = int64(Param{9}), ...
                shuffle = false, ... %keep constant, not an option. 
                random_state = int64(Param{10}), ...
                tol = double(Param{11}), ...
                verbose = false, ... %keep constant, always no. 
                warm_start = Param{12}, ...
                momentum = double(Param{13}), ...
                nesterovs_momentum = Param{14}, ...
                early_stopping = Param{15}, ...
                validation_fraction = double(Param{16}), ...
                beta_1 = double(Param{17}), ...
                beta_2 = double(Param{18}), ...
                epsilon = double(Param{19}), ...
                n_iter_no_change = int64(Param{20}), ...
                max_fun = int64(Param{21}) ...
                );

            %sklearn errors when size(Y,2) = 1, ndarray needs reshaping 
            if size(Y,2) > 1
                model = model.fit(double(Y), int64(label));
            else
                model = model.fit(py.numpy.array(Y).reshape(int64(-1), int64(1)), int64(label));
            end
        end
    case 'regression'
        model = py.sklearn.neural_network.MLPRegressor( ...
            hidden_layer_sizes = int64(Param{1}), ...
            activation = Param{2}, ...
            solver = Param{3}, ...
            alpha = double(Param{4}), ...
            batch_size = Param{5}, ...
            learning_rate = Param{6}, ...
            learning_rate_init = double(Param{7}), ...
            power_t = double(Param{8}), ...
            max_iter = int64(Param{9}), ...
            shuffle = false, ... %keep constant, not an option. 
            random_state = int64(Param{10}), ...
            tol = double(Param{11}), ...
            verbose = false, ... %keep constant, always no. 
            warm_start = Param{12}, ...
            momentum = double(Param{13}), ...
            nesterovs_momentum = Param{14}, ...
            early_stopping = Param{15}, ...
            validation_fraction = double(Param{16}), ...
            beta_1 = double(Param{17}), ...
            beta_2 = double(Param{18}), ...
            epsilon = double(Param{19}), ...
            n_iter_no_change = int64(Param{20}), ...
            max_fun = int64(Param{21}) ...
            );

        %sklearn errors when size(Y,2) = 1, ndarray needs reshaping 
        if size(Y,2) > 1
            model = model.fit(double(Y), double(label));
        else
            model = model.fit(py.numpy.array(Y).reshape(int64(-1), int64(1)), double(label));
        end
end


%CHECK THIS, predict_liblin() is not defined anymore
if ~ModelOnly
    [param.target] = predict_liblin(label, Y, model);
    param.dec_values = param.target;
    param.val = EVALFUNC(label, param.dec_values);
end


